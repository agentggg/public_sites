from time import sleep
from gpiozero import OutputDevice
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685
from logger import setup_logger
import sys
import threading


log = setup_logger(__name__)


class MotorMotions:
    def __init__(self):
        self.I2C = busio.I2C(SCL, SDA)
        self.PCA = PCA9685(self.I2C)
        self.PCA.frequency = 200

        # Physical FRONT wheels  -> Channel A  (GPIO 21/20, 16/12)  PWM 2/3
        # Physical REAR wheels   -> Channel B  (GPIO 23/24, 27/22)  PWM 0/1
        # ============================================================

        # ---------------- FRONT MOTORS (LAMP SIDE) ----------------
        # FRONT RIGHT → Channel A → IN1 / IN2
        self.IN1_FRONT_RIGHT_FORWARD = 21   # BCM21 → Channel A IN1
        self.IN2_FRONT_RIGHT_REVERSE = 20   # BCM20 → Channel A IN2

        # FRONT LEFT → Channel A → IN3 / IN4
        self.IN3_FRONT_LEFT_FORWARD  = 16   # BCM16 → Channel A IN3
        self.IN4_FRONT_LEFT_REVERSE  = 12   # BCM12 → Channel A IN4

        # ---------------- REAR MOTORS ----------------
        # REAR RIGHT → Channel B → IN1 / IN2
        self.IN1_REAR_RIGHT_FORWARD  = 23   # BCM23 → Channel B IN1
        self.IN2_REAR_RIGHT_REVERSE  = 24   # BCM24 → Channel B IN2

        # REAR LEFT → Channel B → IN3 / IN4
        self.IN3_REAR_LEFT_FORWARD   = 27   # BCM27 → Channel B IN3
        self.IN4_REAR_LEFT_REVERSE   = 22   # BCM22 → Channel B IN4

        # ============================================================
        # SPEED / ENABLE (PCA9685 PWM)
        # ============================================================

        # FRONT SPEED (Channel A)
        self.ENA_FRONT_RIGHT = 2     # PCA9685 CH2
        self.ENB_FRONT_LEFT  = 3     # PCA9685 CH3

        # REAR SPEED (Channel B)
        self.ENA_REAR_RIGHT  = 0     # PCA9685 CH0
        self.ENB_REAR_LEFT   = 1     # PCA9685 CH1

        # ============================================================
        # GPIO OUTPUT DEVICES
        # ============================================================

        # FRONT RIGHT
        self.IN1_FRONT_RIGHT_FORWARD_OUTPUT = OutputDevice(self.IN1_FRONT_RIGHT_FORWARD)
        self.IN2_FRONT_RIGHT_REVERSE_OUTPUT = OutputDevice(self.IN2_FRONT_RIGHT_REVERSE)

        # FRONT LEFT
        self.IN3_FRONT_LEFT_FORWARD_OUTPUT  = OutputDevice(self.IN3_FRONT_LEFT_FORWARD)
        self.IN4_FRONT_LEFT_REVERSE_OUTPUT  = OutputDevice(self.IN4_FRONT_LEFT_REVERSE)

        # REAR RIGHT
        self.IN1_REAR_RIGHT_FORWARD_OUTPUT  = OutputDevice(self.IN1_REAR_RIGHT_FORWARD)
        self.IN2_REAR_RIGHT_REVERSE_OUTPUT  = OutputDevice(self.IN2_REAR_RIGHT_REVERSE)

        # REAR LEFT
        self.IN3_REAR_LEFT_FORWARD_OUTPUT   = OutputDevice(self.IN3_REAR_LEFT_FORWARD)
        self.IN4_REAR_LEFT_REVERSE_OUTPUT   = OutputDevice(self.IN4_REAR_LEFT_REVERSE)

        self.FRONT_ALL_MOTORS = [
            self.IN1_FRONT_RIGHT_FORWARD_OUTPUT,
            self.IN2_FRONT_RIGHT_REVERSE_OUTPUT,
            self.IN3_FRONT_LEFT_FORWARD_OUTPUT,
            self.IN4_FRONT_LEFT_REVERSE_OUTPUT
        ]
        self.REAR_ALL_MOTORS = [
            self.IN1_REAR_RIGHT_FORWARD_OUTPUT,
            self.IN2_REAR_RIGHT_REVERSE_OUTPUT,
            self.IN3_REAR_LEFT_FORWARD_OUTPUT,
            self.IN4_REAR_LEFT_REVERSE_OUTPUT
        ]
    # ============================================================
    # FORWARD = MOVE TOWARD LAMP
    # ============================================================
    def stop(self):
        speed = 0

        # Speed ON for all wheels
        self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = speed
        self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = speed
        self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = speed
        self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = speed

        # Clear direction pins
        self.IN1_FRONT_RIGHT_FORWARD_OUTPUT.off()
        self.IN2_FRONT_RIGHT_REVERSE_OUTPUT.off()
        self.IN3_FRONT_LEFT_FORWARD_OUTPUT.off()
        self.IN4_FRONT_LEFT_REVERSE_OUTPUT.off()

        self.IN1_REAR_RIGHT_FORWARD_OUTPUT.off()
        self.IN2_REAR_RIGHT_REVERSE_OUTPUT.off()
        self.IN3_REAR_LEFT_FORWARD_OUTPUT.off()
        self.IN4_REAR_LEFT_REVERSE_OUTPUT.off()

    def forward(self, sleep_time=5):
        try:
            self.stop()
            speed = 26214
            # Speed ON for all wheels
            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = speed
            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = speed
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = speed
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = speed

            # FORWARD (polarity flipped): use IN2/IN4 as the "forward" drive pin
            self.IN2_FRONT_RIGHT_REVERSE_OUTPUT.on()
            self.IN4_FRONT_LEFT_REVERSE_OUTPUT.on()
            self.IN2_REAR_RIGHT_REVERSE_OUTPUT.on()
            self.IN4_REAR_LEFT_REVERSE_OUTPUT.on()

            sleep(sleep_time)

            # Stop PWM
            # self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = 0
            # self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = 0
            # self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = 0
            # self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = 0

            return True

        except Exception as e:
            log.debug(f"error: {e}")
            return False

    def reverse(self, sleep_time=5):
        try:
            self.stop()
            speed = 26214

            # Speed ON for all wheels
            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = speed
            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = speed
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = speed
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = speed

            self.IN1_FRONT_RIGHT_FORWARD_OUTPUT.on()
            self.IN3_FRONT_LEFT_FORWARD_OUTPUT.on()
            self.IN1_REAR_RIGHT_FORWARD_OUTPUT.on()
            self.IN3_REAR_LEFT_FORWARD_OUTPUT.on()

            sleep(sleep_time)

            # Stop PWM
            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = 0
            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = 0
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = 0
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = 0

            return True

        except Exception as e:
            log.debug(f"error: {e}")
            return False
    
    def turn_left_soft(self):
        """
            | Side         | Action          |
            | ------------ | --------------- |
            | Right wheels | FORWARD         |
            | Left wheels  | STOP or REVERSE |
        """
        try:
            self.stop()
            speed = 65535
            # Speed ON for all wheels
            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = 26214
            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = 26214
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = speed
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = speed

            def run_forward():
                self.forward(5)
            move_thread = threading.Thread(target=run_forward)
            move_thread.start() 
            self.IN1_FRONT_RIGHT_FORWARD_OUTPUT.on()
            self.IN1_REAR_RIGHT_FORWARD_OUTPUT.on()
            self.IN4_FRONT_LEFT_REVERSE_OUTPUT.on()
            self.IN4_REAR_LEFT_REVERSE_OUTPUT.on()
            sleep(5)
            self.stop()
            # self.forward(2)  
            # sleep(2)

            self.stop()
            return True
        except Exception as e:
            return e

    def reverse_turn_right_soft(self, duration=2):
        """
        PURPOSE
        -------
        Drive the robot forward while simultaneously turning to the right
        using differential steering (speed imbalance), NOT by reversing wheels.

        This produces a smooth curved ("arc") motion instead of a pivot or spin.
        The robot continues moving forward the entire time.

        ------------------------------------------------------------------------

        CORE CONCEPT (VERY IMPORTANT)
        -----------------------------
        This robot uses DIFFERENTIAL DRIVE.

        Differential drive rules:
        - Direction pins decide *forward vs reverse*
        - PWM decides *how fast* each wheel turns
        - Turning while moving forward is achieved by SPEED DIFFERENCE,
        not by changing direction pins.

        To turn RIGHT while moving forward:
            - LEFT wheels must spin FASTER
            - RIGHT wheels must spin SLOWER
            - ALL wheels must still be in the FORWARD direction

        If any wheel reverses direction:
            - That is NOT a "forward turn"
            - That becomes a pivot or spin

        ------------------------------------------------------------------------

        INVERTED MOTOR NOTE (CRITICAL TO YOUR HARDWARE)
        -----------------------------------------------
        On THIS robot, the electrical meaning of "forward" is inverted.

        That means:
            - Turning ON the "reverse" pin causes the wheel to move forward
            - Turning ON the "forward" pin causes the wheel to move backward

        This usually happens when:
            - Motor wires are swapped on the driver output
            - IN1 / IN2 labeling does not match physical orientation

        Therefore:
            "Forward motion" in this function is achieved by:
                FORWARD_PIN = OFF
                REVERSE_PIN = ON

        This is intentional and verified by physical testing.

        ------------------------------------------------------------------------

        PARAMETERS
        ----------
        base_speed : int (0–65535)
            The baseline PWM value applied to all wheels when driving straight.
            Think of this as the robot's cruising speed.

            Example:
                45000 ≈ fast forward
                30000 ≈ medium forward
                <20000 may not overcome motor friction

        turn_delta : int (0–65535)
            The amount of speed difference used to steer.

            This value is:
                - ADDED to the left wheels
                - SUBTRACTED from the right wheels

            Larger values = sharper turns
            Smaller values = gentler curves

        duration : float (seconds)
            How long the robot should maintain this motion.

            This is REQUIRED for one-off tests.
            In joystick-based control, this would be removed and
            the function would be called repeatedly inside a loop.

        ------------------------------------------------------------------------

        SPEED CALCULATION LOGIC
        -----------------------
        left_speed  = base_speed + turn_delta
        right_speed = base_speed - turn_delta

        Result:
            left_speed  > right_speed

        This causes:
            - Left wheels to push harder
            - Right wheels to lag behind
            - Robot curves to the RIGHT while still moving forward

        Values are clamped:
            - left_speed never exceeds 65535
            - right_speed never drops below 0

        ------------------------------------------------------------------------

        SAFETY BEHAVIOR
        ---------------
        - Motors are stopped before starting to prevent conflicting states
        - Motors are stopped again after the duration expires
        - If any error occurs, motors are immediately stopped

        This prevents:
            - Shorted H-bridge states
            - Runaway motion
            - Overheating

        ------------------------------------------------------------------------

        SUMMARY (READ THIS BEFORE MODIFYING)
        ------------------------------------
        - Turning while moving = PWM math, not direction changes
        - All wheels must agree on "forward"
        - Steering is controlled ONLY by speed difference
        - If robot moves backward, motor polarity is inverted
        - If robot spins, you reversed one side by mistake

        Study this logic. Every movement function builds on this.
        """
        try:
            # SAFETY: stop everything first
            self.stop()

            # ---------------- LEFT SIDE FORWARD ----------------
            # Front Left
            self.IN3_FRONT_LEFT_FORWARD_OUTPUT.on()
            self.IN4_FRONT_LEFT_REVERSE_OUTPUT.off()

            # Rear Left
            self.IN3_REAR_LEFT_FORWARD_OUTPUT.on()
            self.IN4_REAR_LEFT_REVERSE_OUTPUT.off()

            # ---------------- RIGHT SIDE STOP ----------------
            # Front Right
            self.IN1_FRONT_RIGHT_FORWARD_OUTPUT.off()
            self.IN2_FRONT_RIGHT_REVERSE_OUTPUT.off()

            # Rear Right
            self.IN1_REAR_RIGHT_FORWARD_OUTPUT.off()
            self.IN2_REAR_RIGHT_REVERSE_OUTPUT.off()

            # ---------------- SPEED ----------------
            LEFT_SPEED = 26214   # ~40%
            RIGHT_SPEED = 0

            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle = LEFT_SPEED
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle  = LEFT_SPEED

            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = RIGHT_SPEED
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = RIGHT_SPEED

            sleep(duration)

            self.stop()
            return True

        except Exception as e:
            self.stop()
            return e

    def drive_reverse_right(self, base_speed=30000, turn_delta=15000):
        """
        Drive forward while turning right.
        Left wheels faster than right wheels.
        """
        try:
            self.stop()

            # ---------------- ALL WHEELS FORWARD ----------------
            # Front Right
            self.IN1_FRONT_RIGHT_FORWARD_OUTPUT.on()
            self.IN2_FRONT_RIGHT_REVERSE_OUTPUT.off()

            # Rear Right
            self.IN1_REAR_RIGHT_FORWARD_OUTPUT.on()
            self.IN2_REAR_RIGHT_REVERSE_OUTPUT.off()

            # Front Left
            self.IN3_FRONT_LEFT_FORWARD_OUTPUT.on()
            self.IN4_FRONT_LEFT_REVERSE_OUTPUT.off()

            # Rear Left
            self.IN3_REAR_LEFT_FORWARD_OUTPUT.on()
            self.IN4_REAR_LEFT_REVERSE_OUTPUT.off()

            # ---------------- SPEED DIFFERENTIAL ----------------
            left_speed  = min(65535, base_speed + turn_delta)
            right_speed = max(0, base_speed - turn_delta)

            self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle  = left_speed
            self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle   = left_speed

            self.PCA.channels[self.ENA_FRONT_RIGHT].duty_cycle = right_speed
            self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle  = right_speed
            sleep(5)
            return True

        except Exception as e:
            self.stop()
            return e

    # def drive_left_right(self, base_speed=30000, turn_delta=15000):
    #     try:
    #         self.stop()

    #         # ---------------- ALL WHEELS FORWARD ----------------
    #         # Front Right
    #         self.IN1_FRONT_LEFT_FORWARD_OUTPUT.on()
    #         self.IN2_FRONT_LEFT_REVERSE_OUTPUT.off()

    #         # Rear Right
    #         self.IN1_REAR_LEFT_FORWARD_OUTPUT.on()
    #         self.IN2_REAR_LEFT_REVERSE_OUTPUT.off()

    #         # Front Left
    #         self.IN3_FRONT_RIGHT_FORWARD_OUTPUT.on()
    #         self.IN4_FRONT_RIGHT_REVERSE_OUTPUT.off()

    #         # Rear Left
    #         self.IN3_REAR_RIGHT_FORWARD_OUTPUT.on()
    #         self.IN4_REAR_RIGHT_REVERSE_OUTPUT.off()

    #         # ---------------- SPEED DIFFERENTIAL ----------------
    #         right_speed  = min(65535, base_speed + turn_delta)
    #         left_speed = max(0, base_speed - turn_delta)

    #         self.PCA.channels[self.ENB_REAR_LEFT].duty_cycle  = left_speed
    #         self.PCA.channels[self.ENB_FRONT_LEFT].duty_cycle   = left_speed

    #         self.PCA.channels[self.ENA_REAR_RIGHT].duty_cycle = right_speed
    #         self.PCA.channels[self.ENA_LEFT_RIGHT].duty_cycle  = right_speed
    #         sleep(5)
    #         return True

    #     except Exception as e:
    #         self.stop()
    #         return e



    def main(self, direction):
        method = getattr(self, direction)
        return method()

 
if __name__ == "__main__":
    direction = sys.argv[1]
    robot = MotorMotions()
    try:
        result = robot.main(direction)
        log.info("motion: %s", result)
    finally:
        try:
            robot.PCA.deinit()
        except Exception:
            pass


