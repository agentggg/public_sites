# https://roboquant.org/tutorial/strategy.html
# https://roboquant.org/index.html
# https://github.com/neurallayer/roboquant.py
# https://kernc.github.io/backtesting.py/doc/backtesting/#tutorials&gsc.tab=0


import backtrader as bt
import yfinance as yf
import pandas as pd
from datetime import date, timedelta, time
import sys
import os


class CSVFeed(bt.feeds.GenericCSVData):
    params = (
        ("dtformat", "%Y-%m-%d %H:%M:%S"),  # Datetime format in your CSV
        ("datetime", 2),         # "Datetime" column is at index 2
        ("open", 3),
        ("high", 4),
        ("low", 5),
        ("close", 6),
        ("volume", 7),
        ("openinterest", -1),
        ("timeframe", bt.TimeFrame.Minutes),  # 1-minute candles
        ("compression", 1),
    )
cerebro = bt.Cerebro()


data_folder = "data/raw_data"
data_files = [f for f in os.listdir(data_folder) if f.endswith(".csv")]
# Clean and write output
os.makedirs(data_folder, exist_ok=True)
clean_tickets = []


for file in os.listdir(data_folder):
    if file.endswith(".csv"):
        path = os.path.join(data_folder, file)

        # üßπ Strip quotes from "Datetime" column if needed
        try:
            df = pd.read_csv(path)
            if "Datetime" in df.columns:
                df["Datetime"] = df["Datetime"].astype(str).str.replace('"', '', regex=False)
                df.to_csv(path, index=False)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not clean quotes in {file}: {e}")
            continue

        # üìä Load into Backtrader
        data = CSVFeed(dataname=path)
        cerebro.adddata(data, name=file.split("_")[0])


for filename in data_files:
    data_path = os.path.join(data_folder, filename)
    data = CSVFeed(dataname=data_path)
    cerebro.adddata(data, name=filename.split("_")[0])


class SanityStrategy(bt.Strategy):
    def __init__(self):
        self.up = None 
        self.down = None
        self.flat = None
        self.total_reversals = None
        self.reversal_control = []
        self.trigger_reversal_notification = None
        self.thirty_min_prices = []
        self.high = None
        self.low = None
        self.orb_high_marked = None
        self.orb_low_marked = None
        self.entry_price = None
        self.stop_loss = None
        self.take_profit = None
        self.risk_amount = None
        self.reward_amount = None
        self.measure_risk = True
        self.orb_closing_trade = None
        self.last_trade_date = None
        self.entry_time = None
        self.final_result = []
        self.pip_dollar_conversion = {
            "sp500_clean": 50,
            "gold_clean": 100,
            "nasdaq100_clean": 20,
            "silver_clean": 5000,
            "GC=F_clean": 100
        }

        self.holidays = {
            date(2026, 1, 1),   # New Year's Day
            date(2026, 1, 19),  # Martin Luther King Jr. Day
            date(2026, 2, 16),  # Presidents' Day
            date(2026, 4, 3),   # Good Friday
            date(2026, 5, 25),  # Memorial Day
            date(2026, 6, 19),  # Juneteenth
            date(2026, 7, 3),   # Independence Day (Observed)
            date(2026, 9, 7),   # Labor Day
            date(2026, 11, 26), # Thanksgiving Day
            date(2026, 12, 25), # Christmas Day
        }
        self.target_date = date(2026, 1, 2)
        
    def bar_direction(self, data):
        now = data.close[0]
        prev = data.close[-1]
        if now == prev:
            price_direction = "flat"
            price_change = f"No price change detected at bar {len(data)}"
            # self.reversal_control.append('flat')
            self.flat += 1 

        elif now < prev:
            price_direction = "down"
            price_change = f"Price change went down at bar {len(data)}"
            self.reversal_control.append('down')
            self.down += 1

        elif now > prev:
            price_direction = "up"
            price_change = f"Price change went up at bar {len(data)}"
            self.reversal_control.append('up')
            self.up += 1
  
    def reversals(self, data):
        current = self.reversal_control[-1]
        previous = self.reversal_control[-2]
        if current != previous:
            # print(f"REVERSAL at bar {len(self.data)} - time {self.datas[0].datetime.datetime(0)}")            
            self.total_reversals += 1

    def orb_marking(self, data):    
        ticker = data._name
        current_datetime = data.datetime.datetime(0)
        current_date = current_datetime.date()
        current_time = current_datetime.time()

        start_time = time(14, 30)
        end_time = time(14, 30)

        # 1. Skip if holiday or already traded today
        if current_date in self.holidays or self.last_trade_date == current_date:
            return

        # 2. AUTO-CATCH: If market moved to a new day but target_date is stuck in the past
        if current_date > self.target_date:
            self.target_date = current_date
            self.measure_risk = True # Reset for the new day
            # Ensure new target_date isn't a weekend or holiday
            while self.target_date.weekday() >= 5 or self.target_date in self.holidays:
                self.target_date += timedelta(days=1)

        # 3. Marking the ORB levels
        if current_date == self.target_date and start_time <= current_time <= end_time:
            self.orb_high_marked = data.high[0]
            self.orb_low_marked = data.low[0]
            return
        
        # 4. Entry and Exit Logic
        else:
            if self.measure_risk == True:
                if current_date == self.target_date:
                    # bull
                    if self.orb_high_marked < data.close[0]:
                        self.entry_price = data.close[0]
                        self.entry_time = data.datetime.datetime(0)
                        self.stop_loss = data.low[0]
                        self.risk_amount = self.entry_price - self.stop_loss
                        self.reward_amount = self.risk_amount * 2
                        self.take_profit = self.entry_price + self.reward_amount
                        self.measure_risk = False
                    # bear
                    elif self.orb_low_marked > data.close[0]:
                        self.entry_price = data.close[0]
                        self.stop_loss = data.high[0]
                        self.entry_time = data.datetime.datetime(0)
                        self.risk_amount = self.entry_price - self.stop_loss
                        self.reward_amount = self.risk_amount * 2
                        self.take_profit = self.entry_price - self.reward_amount
                        self.measure_risk = False

            elif self.measure_risk == False:
                day_completed = False

                if data.close[0] > self.take_profit: # Win condition
                    self.final_result.append({
                        "result":"win",
                        "date":f"{current_date} - {current_time}",
                        "closing":data.close[0],
                        "PnL":self.reward_amount * self.pip_dollar_conversion[ticker],
                        "s/l": self.stop_loss,
                        "t/p": self.take_profit,
                        "entry": self.entry_price,
                        # "entry_time":self.entry_time.time()
                    })
                    day_completed = True
                
                elif data.close[0] < self.stop_loss: # Loss condition
                    self.final_result.append({
                        "result": "lose",
                        "date": f"{current_date} - {current_time}",
                        "closing": data.close[0],
                        "PnL": self.risk_amount * self.pip_dollar_conversion[ticker],
                        "s/l": self.stop_loss,
                        "t/p": self.take_profit,
                        "entry": self.entry_price,
                        # "entry_time":self.entry_time.time()
                    })
                    day_completed = True

                if day_completed:
                    self.last_trade_date = current_date # Lock this day
                    self.measure_risk = True
                    self.target_date += timedelta(days=1)
                    
                    while self.target_date.weekday() >= 5 or self.target_date in self.holidays:
                        self.target_date += timedelta(days=1)

    def reporting(self):
        # Configuration
        pass_combine = 3000  # Profit Target
        fail_combine = -2000 # Max Loss/Drawdown

        total = 0
        found_at_index = None
        status = "Ongoing"

        # Extracting PnL
        pnl = [trade['PnL'] for trade in self.final_result]
        for index, amount in enumerate(pnl):
            total += amount  # Update total first
            
            if total >= pass_combine:
                status = "PASSED"
                found_at_index = index
                break
            elif total <= fail_combine:
                status = "FAILED"
                found_at_index = index
                break
        print(f"Total Profit and Loss for the {len(self.final_result)} days of trading is {round(sum(pnl))}")
        # Output Results
        if found_at_index is not None:
            print(f"Outcome: {status}")
            print(f"Stopped at Day: {found_at_index + 2}")
            print(f"Date of Outcome: {self.final_result[found_at_index + 2]['date']}")
            print(f"Final Pass Balance: {total:.2f}")
        else:
            print(f"Combine still in progress. Current Balance: {total:.2f}")
    
    def stop(self):
        # This runs ONLY ONCE at the very end of the backtest
        print(f"Backtest complete. Running final analysis for {self.data._name}...")
        self.reporting()
        
    def next(self):
        
        self.orb_marking(self.datas[int(sys.argv[1])])

cerebro.addstrategy(SanityStrategy)
cerebro.run()