<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>PRISM DECK // Gesture</title>

  <style>
    :root{
      --bg0:#f6fbff;
      --bg1:#f3f6ff;
      --bg2:#f9f7ff;

      --ink:#0b1020;
      --muted: rgba(11,16,32,0.66);
      --faint: rgba(11,16,32,0.46);

      --glass: rgba(255,255,255,0.72);
      --glass2: rgba(255,255,255,0.52);
      --line: rgba(11,16,32,0.12);

      --aqua: rgba(0, 210, 255, 0.95);
      --aquaSoft: rgba(0,210,255,0.20);

      --vio: rgba(130, 95, 255, 0.90);
      --vioSoft: rgba(130,95,255,0.18);

      --lime: rgba(80, 255, 175, 0.92);
      --limeSoft: rgba(80,255,175,0.18);

      --warn: rgba(255, 178, 60, 0.96);
      --warnSoft: rgba(255,178,60,0.18);

      --bad: rgba(255, 70, 115, 0.92);
      --badSoft: rgba(255,70,115,0.18);

      --shadow: 0 24px 80px rgba(11,16,32,0.16);
      --shadow2: 0 12px 40px rgba(11,16,32,0.10);

      --r1: 26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(900px 560px at 10% 10%, rgba(0,210,255,0.18), transparent 60%),
        radial-gradient(820px 540px at 90% 25%, rgba(130,95,255,0.16), transparent 58%),
        radial-gradient(860px 560px at 55% 95%, rgba(80,255,175,0.14), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      overflow-x:hidden;
      overflow-y:auto;
    }

    .app{
      min-height: 100vh;
      padding: clamp(12px, 2.6vw, 20px);
      padding-top: calc(clamp(12px, 2.6vw, 20px) + env(safe-area-inset-top));
      padding-bottom: calc(140px + env(safe-area-inset-bottom));
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    /* ===== Notice Pulse ===== */
    .notice{
      position: sticky;
      top: calc(12px + env(safe-area-inset-top));
      z-index: 80;
      pointer-events:none;
      display:flex;
      justify-content:center;
    }
    .noticeInner{
      width: min(920px, 100%);
      border-radius: var(--r1);
      border: 1px solid rgba(11,16,32,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.82), rgba(255,255,255,0.62));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 180ms ease, transform 180ms ease;
      margin-bottom: 8px;
    }
    .noticeInner.show{ opacity: 1; transform: translateY(0); }

    .noticeLeft{ display:flex; align-items:center; gap: 10px; min-width: 0; }
    .bar{
      width: 10px; height: 26px; border-radius: 999px;
      background: rgba(11,16,32,0.20);
      box-shadow: 0 0 0 10px rgba(11,16,32,0.06);
      flex: 0 0 auto;
    }
    .bar.ok{ background: var(--lime); box-shadow: 0 0 0 10px var(--limeSoft); }
    .bar.warn{ background: var(--warn); box-shadow: 0 0 0 10px var(--warnSoft); }
    .bar.bad{ background: var(--bad); box-shadow: 0 0 0 10px var(--badSoft); }

    .noticeText{ min-width: 0; }
    .noticeText .h{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.84);
      margin:0;
    }
    .noticeText .p{
      margin: 4px 0 0;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.64);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: 76vw;
    }

    /* ===== HUD ===== */
    .hud{
      border-radius: var(--r1);
      border: 1px solid var(--line);
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 12px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }

    .brand{ display:flex; align-items:center; gap: 10px; min-width: 160px; }
    .glyph{
      width: 44px; height: 44px; border-radius: 16px;
      border: 1px solid rgba(11,16,32,0.12);
      background:
        radial-gradient(20px 20px at 30% 28%, rgba(255,255,255,0.95), transparent 65%),
        linear-gradient(180deg, rgba(0,210,255,0.20), rgba(130,95,255,0.12));
      box-shadow: var(--shadow2);
      position:relative;
      overflow:hidden;
    }
    .glyph:before{
      content:"";
      position:absolute;
      inset:-50%;
      background: conic-gradient(
        from 90deg,
        rgba(0,210,255,0.22),
        rgba(130,95,255,0.18),
        rgba(80,255,175,0.16),
        rgba(255,178,60,0.16),
        rgba(0,210,255,0.22)
      );
      opacity: 0.55;
      animation: refract 6.5s ease-in-out infinite;
    }
    @keyframes refract{
      0%{ transform: rotate(0deg) translateX(-6%); opacity:0.20; }
      45%{ opacity:0.60; }
      100%{ transform: rotate(22deg) translateX(6%); opacity:0.20; }
    }

    .brandText{ display:flex; flex-direction:column; gap: 4px; }
    .brandText .t{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.84);
      line-height: 1;
    }
    .brandText .s{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: min(55vw, 520px);
    }

    .hudRight{ display:flex; align-items:center; gap: 10px; justify-content:flex-end; flex-wrap: wrap; }
    .statusPill{
      display:flex; align-items:center; gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.55);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.74);
      max-width: 46vw;
    }

    .dot{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(11,16,32,0.22);
      box-shadow: 0 0 0 9px rgba(11,16,32,0.06);
    }
    .dot.ok{ background: var(--lime); box-shadow: 0 0 0 9px var(--limeSoft); }
    .dot.warn{ background: var(--warn); box-shadow: 0 0 0 9px var(--warnSoft); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 0 9px var(--badSoft); }

    .btn{
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.62);
      color: rgba(11,16,32,0.90);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      min-width: 112px;
      text-align:center;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      box-shadow: 0 10px 30px rgba(11,16,32,0.08);
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.82);
      border-color: rgba(11,16,32,0.18);
    }
    .btn:active{ transform: translateY(0px) scale(0.99); }
    .btn[disabled]{ opacity:0.45; cursor:not-allowed; transform:none; }
    .btn.primary{
      border-color: rgba(0,210,255,0.34);
      background: linear-gradient(180deg, rgba(0,210,255,0.18), rgba(255,255,255,0.62));
    }

    /* ===== Controls strip (human-friendly) ===== */
    .controls{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      padding: 10px 12px;
      border-radius: var(--r1);
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.62);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
    }

    .seg{
      display:flex;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      overflow:hidden;
      background: rgba(255,255,255,0.62);
    }
    .seg button{
      border:none;
      background: transparent;
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.72);
      cursor:pointer;
    }
    .seg button.active{
      background: linear-gradient(180deg, rgba(0,210,255,0.16), rgba(255,255,255,0.66));
      color: rgba(11,16,32,0.90);
    }

    .toggle{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.62);
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.74);
      cursor:pointer;
      user-select:none;
    }
    .switch{
      width: 44px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.14);
      background: rgba(11,16,32,0.06);
      position: relative;
    }
    .knob{
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 10px 24px rgba(11,16,32,0.14);
      position:absolute;
      left: 2px;
      top: 1px;
      transition: left 140ms ease;
    }
    .toggle.on .switch{
      background: rgba(80,255,175,0.18);
      border-color: rgba(80,255,175,0.28);
    }
    .toggle.on .knob{ left: 22px; }

    /* ===== Viewport (angled) ===== */
    .viewport{
      position: relative;
      flex: 1 1 auto;
      min-height: 420px;
      border-radius: var(--r1);
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.56);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .frame{
      position:absolute;
      inset: 10px;
      border-radius: 20px;
      overflow:hidden;
      clip-path: polygon(0% 6%, 6% 0%, 94% 0%, 100% 6%, 100% 94%, 94% 100%, 6% 100%, 0% 94%);
      border: 1px solid rgba(11,16,32,0.14);
      background: rgba(11,16,32,0.04);
      touch-action: manipulation;
    }

    video{
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.98;
      filter: contrast(1.04) saturate(1.03);
    }

    .lattice{
      position:absolute; inset:0; pointer-events:none; opacity: 0.35;
      background:
        linear-gradient(90deg, rgba(11,16,32,0.10) 1px, transparent 1px),
        linear-gradient(180deg, rgba(11,16,32,0.10) 1px, transparent 1px);
      background-size: 42px 42px;
      mask-image: radial-gradient(closest-side at 50% 50%, rgba(0,0,0,1) 35%, rgba(0,0,0,0) 78%);
    }

    .scanA, .scanB{
      position:absolute; left:-20%; right:-20%;
      height: 14px; border-radius: 999px;
      opacity: 0; pointer-events:none;
      transform: rotate(-10deg);
    }
    .processing .scanA{
      opacity: 1;
      top: 30%;
      background: linear-gradient(90deg, transparent, rgba(0,210,255,0.20), transparent);
      animation: scan 1.2s ease-in-out infinite;
    }
    .processing .scanB{
      opacity: 1;
      top: 62%;
      background: linear-gradient(90deg, transparent, rgba(130,95,255,0.18), transparent);
      animation: scan 1.4s ease-in-out infinite reverse;
    }
    @keyframes scan{
      0%{ transform: translateX(-20%) rotate(-10deg); opacity: 0; }
      20%{ opacity: 0.9; }
      100%{ transform: translateX(20%) rotate(-10deg); opacity: 0; }
    }

    /* Reticle exists, but is hidden unless Targeting is ON */
    .reticle{
      position:absolute;
      left: 50%;
      top: 50%;
      width: 132px;
      height: 92px;
      transform: translate(-50%,-50%);
      border-radius: 18px;
      border: 1px solid rgba(11,16,32,0.16);
      background: rgba(255,255,255,0.22);
      box-shadow: 0 16px 50px rgba(11,16,32,0.10);
      backdrop-filter: blur(10px);
      cursor: grab;
      touch-action: none;
      display:none;
    }
    .reticle.enabled{ display:block; }
    .reticle:active{ cursor: grabbing; }
    .reticle .crossH, .reticle .crossV{
      position:absolute; left:50%; top:50%;
      transform: translate(-50%,-50%);
      background: rgba(11,16,32,0.14);
      border-radius: 999px;
    }
    .reticle .crossH{ width: 96px; height: 1px; }
    .reticle .crossV{ width: 1px; height: 56px; }
    .reticle .tag{
      position:absolute; left: 10px; top: 10px;
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.70);
    }

    /* ===== Bottom ribbon ===== */
    .ribbon{
      position: fixed;
      left: clamp(12px, 2.6vw, 20px);
      right: clamp(12px, 2.6vw, 20px);
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index: 70;
      border-radius: var(--r1);
      border: 1px solid rgba(11,16,32,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.78), rgba(255,255,255,0.58));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 12px 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .row1{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .classLine{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.72);
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    .classValue{
      font-size: 16px;
      color: rgba(11,16,32,0.92);
      line-height: 1.2;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: min(70vw, 720px);
    }

    .meter{
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(11,16,32,0.05);
      overflow:hidden;
      position:relative;
    }

    .fill{
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(0,210,255,0.25), rgba(0,210,255,0.95), rgba(80,255,175,0.85));
      box-shadow: 0 0 0 12px rgba(0,210,255,0.10);
      transition: width 140ms ease;
      position: relative;
    }
    .fill:after{
      content:"";
      position:absolute;
      inset:-40% -20%;
      background: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.22) 0px,
        rgba(255,255,255,0.22) 10px,
        transparent 10px,
        transparent 22px
      );
      opacity: 0.22;
      animation: flow 1.4s linear infinite;
      pointer-events:none;
    }
    @keyframes flow{
      0%{ transform: translateX(-10%); }
      100%{ transform: translateX(10%); }
    }

    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.56);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.72);
    }
    .chip b{ color: rgba(11,16,32,0.90); font-weight: 700; }

    .row2{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* Debug-only row */
    .debugOnly{ display:none; }
    .debugOn .debugOnly{ display:flex; }

    @media (min-width: 980px){
      .app{ max-width: 1100px; margin: 0 auto; }
      .viewport{ min-height: 560px; }
      .reticle{ width: 170px; height: 120px; }
    }

    /* =========================
       Gesture Impact Layer
       ========================= */
    .impact{
      position: fixed;
      left: 50%;
      top: calc(84px + env(safe-area-inset-top));
      transform: translateX(-50%);
      z-index: 90;
      width: min(980px, calc(100vw - 24px));
      pointer-events: none;
    }

    .impactCard{
      border-radius: 28px;
      border: 1px solid rgba(11,16,32,0.14);
      background:
        radial-gradient(900px 240px at 20% 0%, rgba(0,210,255,0.22), transparent 60%),
        radial-gradient(900px 240px at 80% 0%, rgba(130,95,255,0.20), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,0.90), rgba(255,255,255,0.64));
      box-shadow: 0 30px 110px rgba(11,16,32,0.18);
      backdrop-filter: blur(16px);
      padding: 14px 14px;
      opacity: 0;
      transform: translateY(-10px) scale(0.985);
      transition: opacity 160ms ease, transform 220ms cubic-bezier(.2,.9,.2,1);
      overflow:hidden;
    }
    .impactCard.show{
      opacity: 1;
      transform: translateY(0px) scale(1);
    }

    .impactTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }

    .impactLeft{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
    }

    .gestureEmoji{
      width: 56px;
      height: 56px;
      border-radius: 18px;
      border: 1px solid rgba(11,16,32,0.12);
      background:
        radial-gradient(26px 26px at 30% 28%, rgba(255,255,255,0.98), transparent 65%),
        linear-gradient(180deg, rgba(80,255,175,0.18), rgba(0,210,255,0.14));
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 30px;
      box-shadow: 0 18px 55px rgba(11,16,32,0.10);
      flex: 0 0 auto;
    }

    .gestureText{ min-width: 0; }
    .gestureText .label{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.70);
      margin:0;
    }

    .gestureText .name{
      margin: 6px 0 0;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: rgba(11,16,32,0.96);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: min(74vw, 740px);
    }

    .impactRight{
      display:flex;
      align-items:center;
      gap: 10px;
      justify-content:flex-end;
      flex-wrap: wrap;
    }

    .confPill{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.56);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.74);
      display:flex;
      gap: 8px;
      align-items:center;
    }

    .confPill b{
      color: rgba(11,16,32,0.92);
    }

    .pulseRing{
      position:absolute;
      inset:-40%;
      background: conic-gradient(
        from 90deg,
        rgba(0,210,255,0.22),
        rgba(130,95,255,0.20),
        rgba(80,255,175,0.18),
        rgba(255,178,60,0.18),
        rgba(0,210,255,0.22)
      );
      opacity: 0;
      filter: blur(12px);
      animation: none;
    }

    .impactCard.show .pulseRing{
      opacity: 0.55;
      animation: ring 0.65s ease-out 1;
    }

    @keyframes ring{
      0%{ transform: scale(0.92) rotate(0deg); opacity: 0.0; }
      35%{ opacity: 0.70; }
      100%{ transform: scale(1.06) rotate(16deg); opacity: 0.0; }
    }

    /* =========================
       Gesture Catalog Panel
       ========================= */
    .catalog{
      border-radius: var(--r1);
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.62);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      padding: 12px 12px;
    }

    .catalogHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .catalogTitle{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.72);
    }

    .catalogBtn{
      border: 1px solid rgba(11,16,32,0.12);
      background: rgba(255,255,255,0.62);
      color: rgba(11,16,32,0.86);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
    }

    .catalogGrid{
      margin-top: 10px;
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    @media (min-width: 760px){
      .catalogGrid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    .gItem{
      border-radius: 18px;
      border: 1px solid rgba(11,16,32,0.12);
      background:
        radial-gradient(180px 120px at 30% 20%, rgba(0,210,255,0.14), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.72), rgba(255,255,255,0.52));
      padding: 10px 10px;
      display:flex;
      gap: 10px;
      align-items:center;
      min-height: 54px;
    }

    .gItem .e{
      width: 40px; height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(11,16,32,0.10);
      background: rgba(255,255,255,0.78);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 22px;
      flex: 0 0 auto;
    }

    .gItem .txt{
      min-width: 0;
      display:flex;
      flex-direction:column;
      gap: 4px;
    }

    .gItem .n{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(11,16,32,0.80);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .gItem .d{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(11,16,32,0.60);
    }
  </style>
</head>

<body>
  <div class="app" id="appRoot">
    <div class="notice">
      <div class="noticeInner" id="noticeInner">
        <div class="noticeLeft">
          <div class="bar" id="noticeBar"></div>
          <div class="noticeText">
            <p class="h" id="noticeH">PRISM</p>
            <p class="p" id="noticeP">‚Äî</p>
          </div>
        </div>
        <div style="font-family: var(--mono); font-size:12px; color: rgba(11,16,32,0.62);" id="noticeHint">
          ‚Äî
        </div>
      </div>
    </div>

    <div class="hud">
      <div class="brand">
        <div class="glyph" aria-hidden="true"></div>
        <div class="brandText">
          <div class="t">PRISM DECK</div>
          <div class="s" id="sessionLine">session: ‚Äî</div>
        </div>
      </div>

      <div class="hudRight">
        <div class="statusPill" title="System status">
          <span class="dot" id="dot"></span>
          <span id="statusText">STANDBY</span>
        </div>
        <button class="btn primary" id="startBtn">Turn Camera On</button>
        <button class="btn" id="stopBtn" disabled>Turn Camera Off</button>
        <button class="btn" id="debugBtn">DEBUG</button>
      </div>
    </div>

    <!-- Human-friendly controls -->
    <div class="controls" id="controlsBar">
      <!-- Camera selector -->
      <div class="seg" aria-label="Camera selection">
        <button id="camFront" class="active" type="button">Front</button>
        <button id="camBack" type="button">Back</button>
      </div>

      <!-- Speed selector (human labels) -->
      <div class="seg" aria-label="Capture speed">
        <button class="active" data-mode-ui="Normal" type="button">Normal</button>
        <button data-mode-ui="Fast" type="button">Fast</button>
        <button data-mode-ui="Battery" type="button">Battery</button>
        <button data-mode-ui="Pause" type="button">Pause</button>
      </div>

      <!-- Targeting toggle -->
      <div class="toggle" id="targetToggle" role="switch" aria-checked="false" tabindex="0" title="Enable reticle targeting">
        <span>Targeting</span>
        <div class="switch"><div class="knob"></div></div>
      </div>

      <div style="margin-left:auto; font-family: var(--mono); font-size:12px; color: var(--muted);" id="modeExplain">
        Normal: balanced
      </div>
    </div>

    <!-- Gesture Impact (big obvious result) -->
    <div class="impact" aria-live="polite" aria-atomic="true">
      <div class="impactCard" id="impactCard">
        <div class="pulseRing" aria-hidden="true"></div>
        <div class="impactTop">
          <div class="impactLeft">
            <div class="gestureEmoji" id="impactEmoji">üñêÔ∏è</div>
            <div class="gestureText">
              <p class="label">Detected gesture</p>
              <p class="name" id="impactName">‚Äî</p>
            </div>
          </div>
          <div class="impactRight">
            <div class="confPill">conf <b id="impactConf">‚Äî</b></div>
            <div class="confPill">hand <b id="impactHand">‚Äî</b></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Available gestures (user friendly) -->
    <div class="catalog" id="catalog">
      <div class="catalogHeader">
        <div class="catalogTitle">Available gestures</div>
        <button class="catalogBtn" id="catalogToggle" type="button">Hide</button>
      </div>
      <div class="catalogGrid" id="catalogGrid"></div>
    </div>

    <div class="viewport" id="viewport">
      <div class="frame" id="frame">
        <video id="video" autoplay playsinline muted></video>
        <div class="lattice" aria-hidden="true"></div>
        <div class="scanA" aria-hidden="true"></div>
        <div class="scanB" aria-hidden="true"></div>

        <div class="reticle" id="reticle" role="application" aria-label="Drag reticle (Targeting ON)">
          <div class="tag" id="reticleTag">TARGET</div>
          <div class="crossH"></div>
          <div class="crossV"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="ribbon" id="ribbon">
    <div class="row1">
      <div>
        <div class="classLine">Gesture</div>
        <div class="classValue" id="classValue">‚Äî</div>
      </div>
      <div class="chip">hand <b id="handed">‚Äî</b></div>
    </div>

    <div class="meter" aria-label="Confidence meter">
      <div class="fill" id="fill"></div>
    </div>

    <!-- Debug row (hidden by default) -->
    <div class="row2 debugOnly" id="debugRow">
      <div class="chip">speed <b id="cycle">‚Äî</b></div>
      <div class="chip">jpeg <b id="jpeg">0.72</b></div>
      <div class="chip">lat <b id="lat">‚Äî</b></div>
      <div class="chip">frame <b id="frameId">‚Äî</b></div>
      <div class="chip">mode <b id="modeOut">AUTO</b></div>
    </div>
  </div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // =========================
    // CONFIG
    // =========================
   const DJANGO_URL = "https://pee-households-housewares-constitutional.trycloudflare.com/gesture_recognition/"; // set your Django endpoint
    // const DJANGO_URL = "http://localhost:8000/gesture_recognition/"; // set your Django endpoint
    const AUTH_TOKEN = ""; // optional

    // Internal modes -> UI labels
    const UI_TO_MODE = { Normal:"AUTO", Fast:"LOCK", Battery:"SLOW", Pause:"FREEZE" };
    const MODE_TO_UI = { AUTO:"Normal", LOCK:"Fast", SLOW:"Battery", FREEZE:"Pause" };

    const MODE_CONFIG = {
      AUTO:   { interval: 220, jpeg: 0.72, blurb: "Normal: balanced" },
      LOCK:   { interval: 160, jpeg: 0.74, blurb: "Fast: quicker updates" },
      SLOW:   { interval: 420, jpeg: 0.70, blurb: "Battery: fewer sends" },
      FREEZE: { interval: 999999, jpeg: 0.76, blurb: "Pause: stops sending" }
    };

    const JPEG_MIN = 0.45;
    const JPEG_MAX = 0.86;

    // =========================
    // Gesture catalog (user friendly)
    // Note: exact set can vary by model; these are common MediaPipe labels.
    // =========================
    const GESTURE_CATALOG = [
      { name: "Open_Palm",   emoji: "üñêÔ∏è", desc: "Open hand" },
      { name: "Closed_Fist", emoji: "‚úä",  desc: "Fist" },
      { name: "Pointing_Up", emoji: "‚òùÔ∏è",  desc: "Point up" },
      { name: "Thumb_Up",    emoji: "üëç",  desc: "Thumb up" },
      { name: "Thumb_Down",  emoji: "üëé",  desc: "Thumb down" },
      { name: "Victory",     emoji: "‚úåÔ∏è",  desc: "Peace sign" },
      { name: "ILoveYou",    emoji: "ü§ü",  desc: "I love you" },
    ];
    const GESTURE_LOOKUP = Object.fromEntries(GESTURE_CATALOG.map(g => [g.name, g]));

    // =========================
    // DOM
    // =========================
    const appRoot = document.getElementById("appRoot");

    const sessionLine = document.getElementById("sessionLine");
    const dot = document.getElementById("dot");
    const statusText = document.getElementById("statusText");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const debugBtn = document.getElementById("debugBtn");

    const camFront = document.getElementById("camFront");
    const camBack = document.getElementById("camBack");

    const controlsBar = document.getElementById("controlsBar");
    const modeExplain = document.getElementById("modeExplain");

    const frame = document.getElementById("frame");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");

    const reticle = document.getElementById("reticle");
    const reticleTag = document.getElementById("reticleTag");
    const targetToggle = document.getElementById("targetToggle");

    const classValue = document.getElementById("classValue");
    const fill = document.getElementById("fill");
    const handed = document.getElementById("handed");

    const cycleEl = document.getElementById("cycle");
    const jpegEl = document.getElementById("jpeg");
    const latEl = document.getElementById("lat");
    const frameIdEl = document.getElementById("frameId");
    const modeOut = document.getElementById("modeOut");

    const noticeInner = document.getElementById("noticeInner");
    const noticeBar = document.getElementById("noticeBar");
    const noticeH = document.getElementById("noticeH");
    const noticeP = document.getElementById("noticeP");
    const noticeHint = document.getElementById("noticeHint");

    // Impact layer
    const impactCard = document.getElementById("impactCard");
    const impactEmoji = document.getElementById("impactEmoji");
    const impactName = document.getElementById("impactName");
    const impactConf = document.getElementById("impactConf");
    const impactHand = document.getElementById("impactHand");

    // Catalog
    const catalogGrid = document.getElementById("catalogGrid");
    const catalogToggle = document.getElementById("catalogToggle");

    // =========================
    // STATE
    // =========================
    let stream = null;
    let running = false;
    let inflight = 0;

    let sessionId = "pr_" + Math.random().toString(16).slice(2, 10);
    let frameId = 0;

    let timer = null;
    let jpegQuality = MODE_CONFIG.AUTO.jpeg;
    let currentMode = "AUTO";
    let paused = false;

    let debugEnabled = false;

    let facingMode = "user"; // "user" (front) or "environment" (back)
    let targetingEnabled = false;

    // Adaptive quality
    const latencies = [];
    const LAT_SAMPLES = 10;

    // Reticle dragging
    let drag = { on:false, dx:0, dy:0 };

    // =========================
    // UI Helpers
    // =========================
    function setStatus(mode, text){
      statusText.textContent = text;
      dot.className = "dot " + (mode || "");
    }

    function setProcessing(on){
      frame.classList.toggle("processing", !!on);
    }

    let noticeTimer = null;
    function pulseNotice(kind, title, message, hint=""){
      if (!debugEnabled){
        if (kind === "ok" && title === "PRISM" && message.startsWith("Seeking")) return;
      }
      noticeH.textContent = title;
      noticeP.textContent = message;
      noticeHint.textContent = hint;
      noticeBar.className = "bar " + (kind || "");
      noticeInner.classList.add("show");
      clearTimeout(noticeTimer);
      noticeTimer = setTimeout(() => noticeInner.classList.remove("show"), 1800);
    }

    function avg(arr){
      if (!arr.length) return 0;
      return Math.round(arr.reduce((a,b)=>a+b,0) / arr.length);
    }

    function adjustQuality(latency){
      latencies.push(latency);
      if (latencies.length > LAT_SAMPLES) latencies.shift();
      const a = avg(latencies);

      if (a > 180 && jpegQuality > JPEG_MIN) jpegQuality = Math.max(JPEG_MIN, jpegQuality - 0.04);
      if (a < 90 && jpegQuality < JPEG_MAX) jpegQuality = Math.min(JPEG_MAX, jpegQuality + 0.02);

      jpegEl.textContent = jpegQuality.toFixed(2);
    }

    function setClassification(name, score){
      if (!name){
        classValue.textContent = "‚Äî";
        fill.style.width = "0%";
        return;
      }
      const pct = Math.max(0, Math.min(100, Math.round((score || 0) * 100)));
      classValue.textContent = `${name}  ‚Ä¢  ${pct}%`;
      fill.style.width = pct + "%";
    }

    function setHandedness(name, score){
      if (!name){
        handed.textContent = "‚Äî";
        return;
      }
      handed.textContent = `${name} ${(Math.round((score || 0) * 100))}%`;
    }

    function setDebug(on){
      debugEnabled = !!on;
      document.body.classList.toggle("debugOn", debugEnabled);
      pulseNotice(debugEnabled ? "ok" : "warn", "PRISM", debugEnabled ? "Debug enabled." : "Debug disabled.");
    }

    // Make the gesture "unmissable"
    function setImpactGesture(name, score, handName, handScore){
      if (!name){
        impactName.textContent = "‚Äî";
        impactEmoji.textContent = "üñêÔ∏è";
        impactConf.textContent = "‚Äî";
        impactHand.textContent = handName ? `${handName} ${Math.round((handScore||0)*100)}%` : "‚Äî";
        impactCard.classList.remove("show");
        return;
      }
      const item = GESTURE_LOOKUP[name] || { emoji: "‚ú®" };
      impactEmoji.textContent = item.emoji;
      impactName.textContent = name.replaceAll("_"," ");
      impactConf.textContent = `${Math.round((score||0)*100)}%`;
      impactHand.textContent = handName ? `${handName} ${Math.round((handScore||0)*100)}%` : "‚Äî";

      impactCard.classList.remove("show");
      void impactCard.offsetWidth; // reflow to re-trigger animation
      impactCard.classList.add("show");
    }

    function renderCatalog(){
      catalogGrid.innerHTML = GESTURE_CATALOG.map(g => `
        <div class="gItem">
          <div class="e">${g.emoji}</div>
          <div class="txt">
            <div class="n">${g.name.replaceAll("_"," ")}</div>
            <div class="d">${g.desc}</div>
          </div>
        </div>
      `).join("");
    }

    // Catalog show/hide
    catalogToggle.addEventListener("click", () => {
      const hidden = catalogGrid.style.display === "none";
      catalogGrid.style.display = hidden ? "grid" : "none";
      catalogToggle.textContent = hidden ? "Hide" : "Show";
    });

    // =========================
    // Targeting toggle
    // =========================
    function setTargeting(on){
      targetingEnabled = !!on;
      targetToggle.classList.toggle("on", targetingEnabled);
      targetToggle.setAttribute("aria-checked", targetingEnabled ? "true" : "false");
      reticle.classList.toggle("enabled", targetingEnabled);
      pulseNotice(targetingEnabled ? "ok" : "warn", "PRISM", targetingEnabled ? "Targeting enabled. Drag the reticle." : "Targeting disabled.");
    }

    targetToggle.addEventListener("click", () => setTargeting(!targetingEnabled));
    targetToggle.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        setTargeting(!targetingEnabled);
      }
    });

    // =========================
    // Mode control (human labels)
    // =========================
    function applyMode(mode){
      currentMode = mode;
      const cfg = MODE_CONFIG[mode] || MODE_CONFIG.AUTO;
      jpegQuality = cfg.jpeg;
      jpegEl.textContent = jpegQuality.toFixed(2);
      cycleEl.textContent = cfg.interval === 999999 ? "paused" : (cfg.interval + "ms");
      modeOut.textContent = mode;
      modeExplain.textContent = cfg.blurb;

      paused = (mode === "FREEZE");

      const uiName = MODE_TO_UI[mode] || "Normal";
      [...controlsBar.querySelectorAll('[data-mode-ui]')].forEach(b => {
        b.classList.toggle("active", b.dataset.modeUi === uiName);
      });

      if (running){
        clearInterval(timer);
        timer = setInterval(tick, cfg.interval);
      }

      pulseNotice("ok", "PRISM", `Mode: ${uiName}`);
    }

    controlsBar.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-mode-ui]");
      if (!btn) return;
      const ui = btn.dataset.modeUi;
      const mode = UI_TO_MODE[ui] || "AUTO";
      applyMode(mode);
    });

    // =========================
    // Camera selection
    // =========================
    async function restartCameraWith(mode){
      facingMode = mode;

      camFront.classList.toggle("active", facingMode === "user");
      camBack.classList.toggle("active", facingMode === "environment");

      if (!running) return;

      pulseNotice("warn", "PRISM", "Switching camera‚Ä¶");
      await stopCamera();
      await startCamera();
      pulseNotice("ok", "PRISM", `Camera: ${facingMode === "user" ? "Front" : "Back"}`);
    }

    camFront.addEventListener("click", () => restartCameraWith("user"));
    camBack.addEventListener("click", () => restartCameraWith("environment"));

    // =========================
    // Camera
    // =========================
    async function startCamera() {
      if (!navigator || !navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function") {
        const isSecure =
          window.isSecureContext ||
          location.hostname === "localhost" ||
          location.hostname === "127.0.0.1";

        const reason = [
          "Camera API not available in this browser/runtime.",
          `Secure context: ${isSecure ? "YES" : "NO"}`,
          `URL: ${location.href}`,
          "",
          "Fix:",
          "- Use HTTPS (or localhost).",
          "- Open in Safari/Chrome directly (not an in-app browser).",
          "- Allow Camera permission in browser settings."
        ].join("\n");

        console.error(reason);
        pulseNotice("bad", "Camera unavailable", "This page cannot access the camera.", isSecure ? "HTTPS OK" : "Needs HTTPS");
        alert(reason);
        throw new Error("getUserMedia unavailable");
      }

      await stopCamera();

      const constraints = {
        video: {
          facingMode: facingMode,
          width: { ideal: 720 },
          height: { ideal: 540 }
        },
        audio: false
      };

      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (err) {
        console.warn("Primary constraints failed, retrying with fallback:", err);
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      }

      video.srcObject = stream;
      await video.play();
    }

    async function stopCamera(){
      if (stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
    }

    function captureBase64(){
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return null;

      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext("2d");

      if (facingMode === "user"){
        ctx.save();
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0, w, h);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0, w, h);
      }

      const dataUrl = canvas.toDataURL("image/jpeg", jpegQuality);
      const b64 = dataUrl.split(",")[1] || "";
      return { b64, w, h };
    }

    // =========================
    // Reticle drag (only active when targetingEnabled)
    // =========================
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function setReticleXY(x, y){
      const fr = frame.getBoundingClientRect();
      const w = reticle.offsetWidth;
      const h = reticle.offsetHeight;

      const nx = clamp(x, 0, fr.width - w);
      const ny = clamp(y, 0, fr.height - h);

      reticle.style.left = nx + "px";
      reticle.style.top = ny + "px";
      reticle.style.transform = "translate(0,0)";
    }

    function getReticleNorm(){
      if (!targetingEnabled) return null;
      const fr = frame.getBoundingClientRect();
      const rr = reticle.getBoundingClientRect();
      const cx = (rr.left - fr.left + rr.width/2) / fr.width;
      const cy = (rr.top - fr.top + rr.height/2) / fr.height;
      return { cx: +cx.toFixed(3), cy: +cy.toFixed(3) };
    }

    function pointerDown(e){
      if (!targetingEnabled) return;
      e.preventDefault();
      const rr = reticle.getBoundingClientRect();
      drag.on = true;
      drag.dx = (e.clientX ?? e.touches?.[0]?.clientX) - rr.left;
      drag.dy = (e.clientY ?? e.touches?.[0]?.clientY) - rr.top;
      reticleTag.textContent = "AIM";
    }

    function pointerMove(e){
      if (!drag.on) return;
      const fr = frame.getBoundingClientRect();
      const clientX = e.clientX ?? e.touches?.[0]?.clientX;
      const clientY = e.clientY ?? e.touches?.[0]?.clientY;
      if (clientX == null || clientY == null) return;
      setReticleXY(clientX - fr.left - drag.dx, clientY - fr.top - drag.dy);
    }

    function pointerUp(){
      if (!drag.on) return;
      drag.on = false;
      reticleTag.textContent = "TARGET";
      const r = getReticleNorm();
      if (r) pulseNotice("ok", "PRISM", `Target set: (${r.cx}, ${r.cy})`);
    }

    reticle.addEventListener("pointerdown", pointerDown);
    window.addEventListener("pointermove", pointerMove);
    window.addEventListener("pointerup", pointerUp);

    // =========================
    // Network
    // =========================
    async function post(payload){
      const headers = { "Content-Type": "application/json" };
      if (AUTH_TOKEN) headers["Authorization"] = "Bearer " + AUTH_TOKEN;

      const res = await fetch(DJANGO_URL, { method:"POST", headers, body: JSON.stringify(payload) });
      const text = await res.text();
      let data = null;
      try { data = JSON.parse(text); } catch {}

      if (!res.ok){
        const msg = data?.error?.message || text || `HTTP ${res.status}`;
        const code = data?.error?.code || "HTTP_ERROR";
        return { ok:false, error:{ code, message: msg }, _http: res.status };
      }
      return data;
    }

    // =========================
    // Loop
    // =========================
    async function tick(){
      if (!running) return;
      if (inflight >= 1) return;
      if (paused) return;

      inflight++;
      setProcessing(true);

      const localFrameId = ++frameId;
      frameIdEl.textContent = String(localFrameId);

      const t0 = performance.now();
      try{
        const snap = captureBase64();
        if (!snap) return;

        const payload = {
          session_id: sessionId,
          frame_id: localFrameId,
          ts_client_ms: Date.now(),
          image: { format: "jpeg", data_b64: snap.b64 },
          telemetry: {
            jpeg_quality: jpegQuality,
            width: snap.w,
            height: snap.h,
            mode: currentMode,
            camera: facingMode,
            reticle: getReticleNorm()
          }
        };

        const data = await post(payload);

        const t1 = performance.now();
        const rtt = Math.round(t1 - t0);
        const shownLatency = data?.latency_ms ?? rtt;
        latEl.textContent = shownLatency + "ms";
        adjustQuality(shownLatency);

        if (!data || data.ok !== true){
          setStatus("bad", "FAULT");
          setClassification(null, 0);
          setHandedness(null, 0);
          setImpactGesture(null, 0, null, 0);
          pulseNotice("bad", "PRISM fault",
            (data?.error?.code || "SERVER_FAULT") + " ‚Äî " + (data?.error?.message || "Unknown error"),
            debugEnabled ? `frame ${localFrameId}` : "");
          return;
        }

        const top = data?.result?.top_gesture;
        const hand = data?.result?.handedness?.[0];

        if (top && top.name){
          setStatus("ok", "TRACKING");
          setClassification(top.name, top.score);
          if (hand) setHandedness(hand.name, hand.score);

          // BIG obvious gesture banner
          setImpactGesture(top.name, top.score, hand?.name, hand?.score);

          pulseNotice("ok", "PRISM", `Locked: ${top.name} (${Math.round((top.score||0)*100)}%)`,
            debugEnabled ? `lat ${shownLatency}ms ‚Ä¢ ${MODE_TO_UI[currentMode]}` : "");
        } else {
          setStatus("warn", "SEEKING");
          setClassification(null, 0);
          if (hand) setHandedness(hand.name, hand.score);

          setImpactGesture(null, 0, hand?.name, hand?.score);

          const w = data?.warnings?.[0] || "NO_HAND";
          pulseNotice("warn", "PRISM", `Seeking‚Ä¶`, debugEnabled ? w : "");
        }

      } catch (e){
        setStatus("bad", "FAULT");
        setImpactGesture(null, 0, null, 0);
        pulseNotice("bad", "PRISM fault", e?.message || String(e));
      } finally {
        inflight--;
        setProcessing(false);
      }
    }

    function startLoop(){
      const cfg = MODE_CONFIG[currentMode] || MODE_CONFIG.AUTO;
      clearInterval(timer);
      timer = setInterval(tick, cfg.interval);
      cycleEl.textContent = cfg.interval === 999999 ? "paused" : (cfg.interval + "ms");
    }

    function stopLoop(){
      running = false;
      clearInterval(timer);
      timer = null;
      inflight = 0;

      setStatus("", "STANDBY");
      setProcessing(false);

      setClassification(null, 0);
      setHandedness(null, 0);
      setImpactGesture(null, 0, null, 0);

      latEl.textContent = "‚Äî";
      frameIdEl.textContent = "‚Äî";

      pulseNotice("", "PRISM", "Standby.");
    }

    // =========================
    // Debug Password Gate
    // =========================
    debugBtn.addEventListener("click", () => {
      if (debugEnabled){
        setDebug(false);
        return;
      }
      const pw = prompt("Enter debug password:");
      if (pw === "cisco"){
        setDebug(true);
      } else {
        pulseNotice("bad", "PRISM", "Incorrect password.");
      }
    });

    // =========================
    // Turn Camera On / Off
    // =========================
    startBtn.addEventListener("click", async () => {
      try{
        startBtn.disabled = true;
        setStatus("warn", "STARTING CAMERA");
        pulseNotice("warn", "PRISM", "Requesting camera access‚Ä¶");

        await startCamera();

        running = true;
        stopBtn.disabled = false;

        sessionLine.textContent = `session: ${sessionId}`;
        applyMode(currentMode);
        startLoop();

        setStatus("ok", "ONLINE");
        pulseNotice("ok", "PRISM", "Online. Detecting gesture by default.", "Targeting is optional.");
      } catch (e){
        startBtn.disabled = false;
        setStatus("bad", "FAULT");
        pulseNotice("bad", "Camera fault", e?.message || String(e));
      }
    });

    stopBtn.addEventListener("click", async () => {
      stopLoop();
      await stopCamera();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      pulseNotice("warn", "PRISM", "Camera off.");
    });

    // =========================
    // Init defaults
    // =========================
    sessionLine.textContent = `session: ${sessionId}`;
    setStatus("", "STANDBY");
    applyMode("AUTO");
    setTargeting(false);
    camFront.classList.add("active");
    camBack.classList.remove("active");
    renderCatalog();
    pulseNotice("", "PRISM", "Ready. Press Turn Camera On to start.");
  </script>
</body>
</html>