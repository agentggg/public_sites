<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ATLAS-VIEW // Hand Landmarks</title>

  <!--
    =========================
    DJANGO CONTRACT (what you send / what Django returns)
    =========================

    FRONTEND -> DJANGO (POST JSON):
    {
      "session_id": "av_9f31a2c1",
      "frame_id": 17,
      "ts_client_ms": 1730000000000,
      "image": { "format": "jpeg", "data_b64": "<BASE64_NO_PREFIX>" },
      "telemetry": {
        "width": 720,
        "height": 540,
        "camera": "user|environment",
        "mirror": true,
        "quality": 0.72,
        "overlays": { "landmarks": true, "labels": true }
      }
    }

    DJANGO -> FRONTEND (200 JSON):
    {
      "ok": true,
      "session_id": "av_9f31a2c1",
      "frame_id": 17,
      "ts_server_ms": 1730000000102,
      "latency_ms": 41,

      "hands": [
        {
          "handedness": { "name": "Left|Right", "score": 0.98 },

          "landmarks": [
            { "id": 0, "x": 0.52, "y": 0.73, "z": -0.02 },
            ...
            { "id": 20, "x": 0.67, "y": 0.28, "z": -0.01 }
          ],

          "fingertips": [
            { "name": "THUMB",  "id": 4,  "x": 0.61, "y": 0.58 },
            { "name": "INDEX",  "id": 8,  "x": 0.62, "y": 0.41 },
            { "name": "MIDDLE", "id": 12, "x": 0.58, "y": 0.39 },
            { "name": "RING",   "id": 16, "x": 0.54, "y": 0.43 },
            { "name": "PINKY",  "id": 20, "x": 0.49, "y": 0.49 }
          ]
        }
      ],

      "warnings": [],
      "error": null
    }

    NO HANDS:
    { "ok": true, "hands": [], ... }

    ERROR:
    { "ok": false, "error": { "code": "IMAGE_MISSING", "message": "image.data_b64 missing" } }
  -->

  <style>
    :root{
      /* Entirely different palette from PRISM */
      --paper:#fff6e9;
      --paper2:#fffaf2;
      --sky:#e8fbff;
      --ink:#11121a;
      --muted: rgba(17,18,26,.64);
      --line: rgba(17,18,26,.14);

      --cobalt: rgba(20, 90, 255, .92);
      --cobaltSoft: rgba(20, 90, 255, .18);

      --coral: rgba(255, 85, 130, .92);
      --coralSoft: rgba(255, 85, 130, .16);

      --mint: rgba(35, 220, 165, .92);
      --mintSoft: rgba(35, 220, 165, .16);

      --amber: rgba(255, 185, 55, .96);
      --amberSoft: rgba(255, 185, 55, .16);

      --shadow: 0 24px 80px rgba(17,18,26,.16);
      --shadow2: 0 12px 40px rgba(17,18,26,.10);

      --r: 24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1000px 600px at 15% 10%, rgba(20,90,255,.13), transparent 58%),
        radial-gradient(1000px 600px at 85% 18%, rgba(255,85,130,.12), transparent 60%),
        radial-gradient(900px 520px at 55% 95%, rgba(35,220,165,.10), transparent 62%),
        linear-gradient(180deg, var(--sky), var(--paper2) 40%, var(--paper));
      overflow-x:hidden;
      overflow-y:auto;
    }

    .app{
      min-height:100vh;
      padding: clamp(12px, 2.8vw, 22px);
      padding-top: calc(clamp(12px, 2.8vw, 22px) + env(safe-area-inset-top));
      padding-bottom: calc(156px + env(safe-area-inset-bottom));
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    /* ===== Atlas Ribbon Header (not boxes, not circles) ===== */
    .topbar{
      border-radius: var(--r);
      border: 1px solid rgba(17,18,26,.12);
      background:
        linear-gradient(180deg, rgba(255,255,255,.78), rgba(255,255,255,.56));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      overflow:hidden;
      position: relative;
    }

    .topbar:before{
      content:"";
      position:absolute;
      inset:-40%;
      background:
        repeating-linear-gradient(
          135deg,
          rgba(20,90,255,.10) 0px,
          rgba(20,90,255,.10) 12px,
          transparent 12px,
          transparent 30px
        );
      opacity: .35;
      transform: rotate(-6deg);
      pointer-events:none;
      mask-image: radial-gradient(closest-side at 50% 20%, rgba(0,0,0,1) 45%, rgba(0,0,0,0) 78%);
    }

    .brand{
      min-width: 160px;
      display:flex;
      flex-direction:column;
      gap: 6px;
      position:relative;
      z-index:2;
    }
    .brand .kicker{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .24em;
      text-transform: uppercase;
      color: rgba(17,18,26,.72);
    }
    .brand .title{
      display:flex;
      align-items:baseline;
      gap: 10px;
      flex-wrap: wrap;
    }
    .brand .title b{
      font-size: 18px;
      letter-spacing: .02em;
    }
    .brand .title span{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.62);
      letter-spacing: .14em;
      text-transform: uppercase;
    }

    .actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
      position:relative;
      z-index:2;
    }

    .pill{
      border-radius: 999px;
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.56);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      gap: 8px;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.74);
      max-width: 70vw;
    }

    .sig{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: rgba(17,18,26,.22);
      box-shadow: 0 0 0 9px rgba(17,18,26,.06);
    }
    .sig.ok{ background: var(--mint); box-shadow: 0 0 0 9px var(--mintSoft); }
    .sig.warn{ background: var(--amber); box-shadow: 0 0 0 9px var(--amberSoft); }
    .sig.bad{ background: var(--coral); box-shadow: 0 0 0 9px var(--coralSoft); }

    .btn{
      border: 1px solid rgba(17,18,26,.14);
      background: rgba(255,255,255,.62);
      color: rgba(17,18,26,.92);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      user-select:none;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .10em;
      text-transform: uppercase;
      box-shadow: 0 10px 30px rgba(17,18,26,.08);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      min-width: 132px;
      text-align:center;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.82);
      border-color: rgba(17,18,26,.18);
    }
    .btn:active{ transform: translateY(0px) scale(0.99); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .btn.primary{
      border-color: rgba(20,90,255,.30);
      background: linear-gradient(180deg, rgba(20,90,255,.16), rgba(255,255,255,.62));
    }

    /* ===== Map Controls (slanted tabs) ===== */
    .controls{
      border-radius: var(--r);
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.62);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      padding: 10px 12px;
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .tabs{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    .tab{
      border-radius: 14px;
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.58);
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(17,18,26,.78);
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transform: skewX(-10deg);
    }
    .tab > span{ display:inline-block; transform: skewX(10deg); }
    .tab.active{
      border-color: rgba(20,90,255,.26);
      background: linear-gradient(180deg, rgba(20,90,255,.14), rgba(255,255,255,.62));
      color: rgba(17,18,26,.92);
    }

    .toggle{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.58);
      cursor:pointer;
      user-select:none;
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(17,18,26,.72);
    }
    .switch{
      width: 44px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(17,18,26,.14);
      background: rgba(17,18,26,.06);
      position: relative;
    }
    .knob{
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255,255,255,.95);
      box-shadow: 0 10px 24px rgba(17,18,26,.14);
      position:absolute;
      left: 2px;
      top: 1px;
      transition: left 140ms ease;
    }
    .toggle.on .switch{
      background: rgba(35,220,165,.16);
      border-color: rgba(35,220,165,.26);
    }
    .toggle.on .knob{ left: 22px; }

    .explain{
      margin-left:auto;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.64);
      letter-spacing: .08em;
      text-transform: uppercase;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: min(64vw, 700px);
    }

    /* ===== Viewport (Atlas Map Glass) ===== */
    .viewport{
      position: relative;
      flex: 1 1 auto;
      min-height: 460px;
      border-radius: var(--r);
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.60);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .frame{
      position:absolute;
      inset: 10px;
      border-radius: 22px;
      overflow:hidden;

      /* Not square/circle; angled ‚Äúatlas window‚Äù */
      clip-path: polygon(3% 0%, 97% 0%, 100% 8%, 100% 92%, 97% 100%, 3% 100%, 0% 92%, 0% 8%);
      border: 1px solid rgba(17,18,26,.14);
      background: rgba(17,18,26,.04);
      touch-action: manipulation;
    }

    video{
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: .98;
      filter: contrast(1.03) saturate(1.05);
      transform: scaleX(-1);
    }

    /* Topographic overlay */
    .topo{
      position:absolute; inset:0; pointer-events:none;
      opacity: .30;
      background:
        repeating-radial-gradient(circle at 30% 30%,
          rgba(17,18,26,.12) 0px,
          rgba(17,18,26,.12) 1px,
          transparent 1px,
          transparent 20px
        );
      mask-image: radial-gradient(closest-side at 50% 50%, rgba(0,0,0,1) 42%, rgba(0,0,0,0) 78%);
      animation: drift 8.5s ease-in-out infinite;
    }
    @keyframes drift{
      0%{ transform: translate(0,0); opacity:.22; }
      50%{ transform: translate(8px,-10px); opacity:.34; }
      100%{ transform: translate(0,0); opacity:.22; }
    }

    /* ‚ÄúProcessing route‚Äù line (not scan bars) */
    .route{
      position:absolute;
      inset:-30%;
      pointer-events:none;
      opacity: 0;
      background:
        linear-gradient(90deg, transparent 40%, rgba(20,90,255,.18) 50%, transparent 60%),
        linear-gradient(120deg, transparent 45%, rgba(255,85,130,.14) 55%, transparent 65%);
      filter: blur(10px);
      transform: rotate(18deg);
    }
    .processing .route{
      opacity: 1;
      animation: route 1.25s ease-in-out infinite;
    }
    @keyframes route{
      0%{ transform: translateX(-12%) rotate(18deg); opacity: 0; }
      25%{ opacity: .85; }
      100%{ transform: translateX(12%) rotate(18deg); opacity: 0; }
    }

    /* Canvas overlay for landmarks */
    canvas.overlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    /* ===== Gesture/Hand Panel (Bottom) ===== */
    .dock{
      position: fixed;
      left: clamp(12px, 2.8vw, 22px);
      right: clamp(12px, 2.8vw, 22px);
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index: 70;

      border-radius: var(--r);
      border: 1px solid rgba(17,18,26,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.80), rgba(255,255,255,.58));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 12px 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .dockRow{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }

    .headline{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 220px;
    }

    .badge{
      border-radius: 14px;
      border: 1px solid rgba(17,18,26,.12);
      background:
        radial-gradient(120px 60px at 30% 20%, rgba(20,90,255,.16), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.72), rgba(255,255,255,.56));
      padding: 10px 12px;
      box-shadow: var(--shadow2);
      display:flex;
      align-items:center;
      gap: 10px;
    }

    .emoji{
      font-size: 26px;
      width: 40px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .hText{ display:flex; flex-direction:column; gap: 4px; min-width: 0; }
    .hText .k{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .18em;
      text-transform: uppercase;
      color: rgba(17,18,26,.70);
    }
    .hText .v{
      font-size: 18px;
      font-weight: 800;
      color: rgba(17,18,26,.96);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: min(72vw, 720px);
    }

    .meters{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .meter{
      min-width: 180px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(17,18,26,.05);
      overflow:hidden;
    }

    .fill{
      height:100%;
      width:0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(255,185,55,.22), rgba(20,90,255,.88), rgba(35,220,165,.90));
      box-shadow: 0 0 0 12px rgba(20,90,255,.10);
      transition: width 140ms ease;
      position:relative;
    }

    .chips{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }

    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.56);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.72);
    }
    .chip b{ color: rgba(17,18,26,.92); font-weight: 800; }

    /* Debug-only */
    .debugOnly{ display:none; }
    .debugOn .debugOnly{ display:flex; }

    /* ===== Toast ===== */
    .toastWrap{
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(12px + env(safe-area-inset-top));
      z-index: 120;
      display:flex;
      justify-content:center;
      pointer-events:none;
    }
    .toast{
      width: min(980px, 100%);
      border-radius: var(--r);
      border: 1px solid rgba(17,18,26,.12);
      background: rgba(255,255,255,.78);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .toast.show{ opacity: 1; transform: translateY(0); }
    .toast .left{
      display:flex; align-items:center; gap: 10px; min-width: 0;
    }
    .toast .bar{
      width: 10px; height: 26px; border-radius: 999px;
      background: rgba(17,18,26,.20);
      box-shadow: 0 0 0 10px rgba(17,18,26,.06);
      flex: 0 0 auto;
    }
    .toast .bar.ok{ background: var(--mint); box-shadow: 0 0 0 10px var(--mintSoft); }
    .toast .bar.warn{ background: var(--amber); box-shadow: 0 0 0 10px var(--amberSoft); }
    .toast .bar.bad{ background: var(--coral); box-shadow: 0 0 0 10px var(--coralSoft); }
    .toast .t{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .20em;
      text-transform: uppercase;
      color: rgba(17,18,26,.84);
      margin:0;
    }
    .toast .p{
      margin: 4px 0 0;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.64);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: 76vw;
    }
    .toast .hint{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(17,18,26,.60);
      letter-spacing: .10em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    @media (min-width: 980px){
      .app{ max-width: 1100px; margin: 0 auto; }
      .viewport{ min-height: 600px; }
    }
  </style>
</head>

<body>
  <div class="toastWrap">
    <div class="toast" id="toast">
      <div class="left">
        <div class="bar" id="toastBar"></div>
        <div>
          <p class="t" id="toastT">ATLAS</p>
          <p class="p" id="toastP">‚Äî</p>
        </div>
      </div>
      <div class="hint" id="toastHint">‚Äî</div>
    </div>
  </div>

  <div class="app" id="app">
    <div class="topbar">
      <div class="brand">
        <div class="kicker">ATLAS-VIEW</div>
        <div class="title">
          <b>Hand Landmarks</b>
          <span id="sessionLine">session: ‚Äî</span>
        </div>
      </div>

      <div class="actions">
        <div class="pill" title="System status">
          <span class="sig" id="sig"></span>
          <span id="statusText">STANDBY</span>
        </div>

        <button class="btn primary" id="startBtn">Turn Camera On</button>
        <button class="btn" id="stopBtn" disabled>Turn Camera Off</button>
        <button class="btn" id="debugBtn">Debug</button>
      </div>
    </div>

    <div class="controls">
      <div class="tabs" aria-label="Camera selection">
        <button class="tab active" id="camFront" type="button"><span>Front</span></button>
        <button class="tab" id="camBack" type="button"><span>Back</span></button>
      </div>

      <div class="tabs" aria-label="Update rate">
        <button class="tab active" data-rate="normal" type="button"><span>Normal</span></button>
        <button class="tab" data-rate="fast" type="button"><span>Fast</span></button>
        <button class="tab" data-rate="battery" type="button"><span>Battery</span></button>
        <button class="tab" data-rate="pause" type="button"><span>Pause</span></button>
      </div>

      <div class="toggle on" id="mirrorToggle" role="switch" aria-checked="true" tabindex="0" title="Mirror preview (selfie)">
        <span>Mirror</span>
        <div class="switch"><div class="knob"></div></div>
      </div>

      <div class="toggle on" id="lmToggle" role="switch" aria-checked="true" tabindex="0" title="Overlay hand landmarks">
        <span>Landmarks</span>
        <div class="switch"><div class="knob"></div></div>
      </div>

      <div class="toggle on" id="lblToggle" role="switch" aria-checked="true" tabindex="0" title="Label fingertips">
        <span>Labels</span>
        <div class="switch"><div class="knob"></div></div>
      </div>

      <div class="explain" id="explain">Normal: balanced updates</div>
    </div>

    <div class="viewport" id="viewport">
      <div class="frame" id="frame">
        <video id="video" autoplay playsinline muted></video>
        <canvas class="overlay" id="overlay"></canvas>
        <div class="topo" aria-hidden="true"></div>
        <div class="route" aria-hidden="true"></div>
      </div>
    </div>
  </div>

  <div class="dock" id="dock">
    <div class="dockRow">
      <div class="headline">
        <div class="badge">
          <div class="emoji" id="handEmoji">üñêÔ∏è</div>
          <div class="hText">
            <div class="k">Detected</div>
            <div class="v" id="detectedLine">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="meters">
        <div class="meter" title="Hand confidence">
          <div class="fill" id="confFill"></div>
        </div>
        <div class="chips">
          <div class="chip">hand <b id="handed">‚Äî</b></div>
          <div class="chip debugOnly">lat <b id="lat">‚Äî</b></div>
          <div class="chip debugOnly">frame <b id="frameId">‚Äî</b></div>
          <div class="chip debugOnly">jpeg <b id="jpegQ">0.72</b></div>
          <div class="chip debugOnly">rate <b id="rateOut">normal</b></div>
        </div>
      </div>
    </div>
  </div>

  <canvas id="capture" style="display:none;"></canvas>

  <script>
    // =========================
    // CONFIG
    // =========================
    const DJANGO_URL = "https://38beafde7ec6.ngrok-free.app/hand_landmarks/"; // <-- your Django endpoint
    const AUTH_TOKEN = ""; // optional

    // Update rates
    const RATE = {
      normal: { interval: 220, jpeg: 0.72, label: "Normal: balanced updates" },
      fast:   { interval: 150, jpeg: 0.74, label: "Fast: quicker tracking" },
      battery:{ interval: 420, jpeg: 0.70, label: "Battery: fewer sends" },
      pause:  { interval: 999999, jpeg: 0.76, label: "Pause: stops sending" },
    };

    const FINGERTIPS = [
      { name:"THUMB",  id: 4,  emoji:"üëç" },
      { name:"INDEX",  id: 8,  emoji:"‚òùÔ∏è" },
      { name:"MIDDLE", id: 12, emoji:"üñï" }, // you can swap if you want a different symbol
      { name:"RING",   id: 16, emoji:"üíç" },
      { name:"PINKY",  id: 20, emoji:"ü§ô" },
    ];
    const TIP_BY_ID = Object.fromEntries(FINGERTIPS.map(t => [t.id, t]));

    // MediaPipe Hands connections (pairs of landmark indices)
    const HAND_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [5,9],[9,10],[10,11],[11,12],
      [9,13],[13,14],[14,15],[15,16],
      [13,17],[17,18],[18,19],[19,20],
      [0,17]
    ];

    // =========================
    // DOM
    // =========================
    const sessionLine = document.getElementById("sessionLine");
    const sig = document.getElementById("sig");
    const statusText = document.getElementById("statusText");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const debugBtn = document.getElementById("debugBtn");

    const camFront = document.getElementById("camFront");
    const camBack = document.getElementById("camBack");

    const mirrorToggle = document.getElementById("mirrorToggle");
    const lmToggle = document.getElementById("lmToggle");
    const lblToggle = document.getElementById("lblToggle");

    const explain = document.getElementById("explain");

    const frame = document.getElementById("frame");
    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const overlayCtx = overlay.getContext("2d");

    const capture = document.getElementById("capture");

    // Dock
    const handEmoji = document.getElementById("handEmoji");
    const detectedLine = document.getElementById("detectedLine");
    const confFill = document.getElementById("confFill");
    const handed = document.getElementById("handed");
    const latEl = document.getElementById("lat");
    const frameIdEl = document.getElementById("frameId");
    const jpegQ = document.getElementById("jpegQ");
    const rateOut = document.getElementById("rateOut");

    // Toast
    const toast = document.getElementById("toast");
    const toastBar = document.getElementById("toastBar");
    const toastT = document.getElementById("toastT");
    const toastP = document.getElementById("toastP");
    const toastHint = document.getElementById("toastHint");

    // =========================
    // STATE
    // =========================
    let stream = null;
    let running = false;
    let inflight = 0;

    let sessionId = "av_" + Math.random().toString(16).slice(2, 10);
    let frameId = 0;

    let timer = null;

    let currentRate = "normal";
    let jpegQuality = RATE[currentRate].jpeg;
    let paused = false;

    let facingMode = "user"; // "user" | "environment"
    let mirror = true;
    let showLandmarks = true;
    let showLabels = true;

    let debugEnabled = false;

    // last known hands (for overlay)
    let lastHands = [];

    // =========================
    // Helpers
    // =========================
    function setStatus(mode, text){
      statusText.textContent = text;
      sig.className = "sig " + (mode || "");
    }

    function setProcessing(on){
      frame.classList.toggle("processing", !!on);
    }

    let toastTimer = null;
    function toastMsg(kind, title, message, hint=""){
      toastT.textContent = title;
      toastP.textContent = message;
      toastHint.textContent = hint || " ";
      toastBar.className = "bar " + (kind || "");
      toast.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => toast.classList.remove("show"), 1700);
    }

    function setDebug(on){
      debugEnabled = !!on;
      document.body.classList.toggle("debugOn", debugEnabled);
      toastMsg(debugEnabled ? "ok" : "warn", "ATLAS", debugEnabled ? "Debug enabled." : "Debug disabled.");
    }

    function setDock(hands){
      if (!hands || hands.length === 0){
        handEmoji.textContent = "üñêÔ∏è";
        detectedLine.textContent = "No hands detected";
        handed.innerHTML = "‚Äî";
        confFill.style.width = "0%";
        return;
      }

      const h0 = hands[0];
      const handName = h0?.handedness?.name || "Hand";
      const handScore = h0?.handedness?.score ?? 0;

      handed.innerHTML = `${handName} ${Math.round(handScore*100)}%`;
      confFill.style.width = Math.max(0, Math.min(100, Math.round(handScore*100))) + "%";

      // Show fingertips summary (human-friendly)
      // Example: "Right ‚Ä¢ üëç THUMB ‚Ä¢ ‚òùÔ∏è INDEX ‚Ä¢ üíç RING"
      const tips = (h0.fingertips || []).slice(0, 5).map(t => {
        const m = TIP_BY_ID[t.id] || {};
        const em = m.emoji || "‚Ä¢";
        return `${em} ${t.name}`;
      });

      detectedLine.textContent = tips.length ? `${handName} ‚Ä¢ ${tips.join(" ‚Ä¢ ")}` : `${handName} ‚Ä¢ landmarks locked`;
    }

    function setRate(rateKey){
      currentRate = rateKey;
      const cfg = RATE[currentRate] || RATE.normal;
      paused = (currentRate === "pause");
      jpegQuality = cfg.jpeg;
      explain.textContent = cfg.label;
      jpegQ.textContent = jpegQuality.toFixed(2);
      rateOut.textContent = currentRate;

      // button UI
      document.querySelectorAll('[data-rate]').forEach(b => {
        b.classList.toggle("active", b.dataset.rate === currentRate);
      });

      if (running){
        clearInterval(timer);
        timer = setInterval(tick, cfg.interval);
      }
      toastMsg("ok", "ATLAS", `Rate: ${currentRate.toUpperCase()}`);
    }

    function setToggle(el, on){
      el.classList.toggle("on", !!on);
      el.setAttribute("aria-checked", on ? "true" : "false");
    }

    function resizeOverlay(){
      // Keep overlay in sync with video rendering size
      const rect = video.getBoundingClientRect();
      overlay.width = Math.max(1, Math.round(rect.width * devicePixelRatio));
      overlay.height = Math.max(1, Math.round(rect.height * devicePixelRatio));
    }

    window.addEventListener("resize", resizeOverlay);

    // =========================
    // Camera
    // =========================
    async function startCamera(){
      if (!navigator || !navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function"){
        const isSecure = window.isSecureContext || location.hostname === "localhost" || location.hostname === "127.0.0.1";
        const msg = [
          "Camera API not available in this browser/runtime.",
          `Secure context: ${isSecure ? "YES" : "NO"}`,
          "",
          "Fix:",
          "- Use HTTPS (or localhost).",
          "- Open in Safari/Chrome directly (not an in-app browser).",
          "- Allow Camera permission."
        ].join("\n");
        console.error(msg);
        alert(msg);
        throw new Error("getUserMedia unavailable");
      }

      await stopCamera();

      const constraints = {
        video: { facingMode: facingMode, width: { ideal: 720 }, height: { ideal: 540 } },
        audio: false
      };

      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (err){
        console.warn("Primary constraints failed, fallback:", err);
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      }

      video.srcObject = stream;
      await video.play();

      // apply mirror
      video.style.transform = mirror ? "scaleX(-1)" : "none";

      // sync overlay size (after video has layout)
      requestAnimationFrame(() => {
        resizeOverlay();
        toastMsg("ok", "ATLAS", "Camera online.");
      });
    }

    async function stopCamera(){
      if (stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
    }

    function captureBase64(){
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return null;

      capture.width = w;
      capture.height = h;
      const ctx = capture.getContext("2d");

      // If mirror is ON, mirror capture to match what user sees
      if (mirror){
        ctx.save();
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0, w, h);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0, w, h);
      }

      const dataUrl = capture.toDataURL("image/jpeg", jpegQuality);
      const b64 = dataUrl.split(",")[1] || "";
      return { b64, w, h };
    }

    // =========================
    // Network
    // =========================
    async function post(payload){
      const headers = { "Content-Type": "application/json" };
      if (AUTH_TOKEN) headers["Authorization"] = "Bearer " + AUTH_TOKEN;

      const res = await fetch(DJANGO_URL, { method:"POST", headers, body: JSON.stringify(payload) });
      const txt = await res.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}

      if (!res.ok){
        const msg = data?.error?.message || txt || `HTTP ${res.status}`;
        const code = data?.error?.code || "HTTP_ERROR";
        return { ok:false, error:{ code, message: msg }, _http: res.status };
      }
      return data;
    }

    // =========================
    // Drawing (overlay)
    // =========================
    function clearOverlay(){
      overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function drawHands(hands){
      clearOverlay();
      if (!showLandmarks || !hands || hands.length === 0) return;

      // We draw in overlay pixel space; landmarks are normalized 0..1
      const W = overlay.width;
      const H = overlay.height;

      for (const hand of hands){
        const lms = hand.landmarks || [];
        if (lms.length < 21) continue;

        // 1) connections
        overlayCtx.save();
        overlayCtx.lineWidth = Math.max(2, Math.round(2 * devicePixelRatio));
        overlayCtx.lineCap = "round";
        overlayCtx.lineJoin = "round";
        overlayCtx.strokeStyle = "rgba(255, 85, 130, 0.92)"; // coral lines (different from your OpenCV red/white)
        overlayCtx.shadowColor = "rgba(255, 85, 130, 0.22)";
        overlayCtx.shadowBlur = 12 * devicePixelRatio;

        overlayCtx.beginPath();
        for (const [a,b] of HAND_CONNECTIONS){
          const A = lms[a], B = lms[b];
          if (!A || !B) continue;
          overlayCtx.moveTo(A.x * W, A.y * H);
          overlayCtx.lineTo(B.x * W, B.y * H);
        }
        overlayCtx.stroke();
        overlayCtx.restore();

        // 2) landmarks dots
        overlayCtx.save();
        overlayCtx.fillStyle = "rgba(20, 90, 255, 0.92)"; // cobalt dots
        overlayCtx.shadowColor = "rgba(20, 90, 255, 0.22)";
        overlayCtx.shadowBlur = 12 * devicePixelRatio;

        const r = 3.2 * devicePixelRatio;
        for (const lm of lms){
          overlayCtx.beginPath();
          overlayCtx.arc(lm.x * W, lm.y * H, r, 0, Math.PI * 2);
          overlayCtx.fill();
        }
        overlayCtx.restore();

        // 3) fingertip labels
        if (showLabels){
          overlayCtx.save();
          overlayCtx.font = `${Math.round(12*devicePixelRatio)}px ${getComputedStyle(document.body).fontFamily}`;
          overlayCtx.fillStyle = "rgba(17,18,26,0.92)";
          overlayCtx.strokeStyle = "rgba(255,255,255,0.92)";
          overlayCtx.lineWidth = 3 * devicePixelRatio;

          const tips = hand.fingertips || [];
          for (const t of tips){
            const meta = TIP_BY_ID[t.id] || {};
            const label = `${meta.emoji || "‚Ä¢"} ${t.name}`;
            const x = (t.x ?? 0) * W;
            const y = (t.y ?? 0) * H;

            // text outline for legibility
            overlayCtx.strokeText(label, x + 10*devicePixelRatio, y - 10*devicePixelRatio);
            overlayCtx.fillText(label, x + 10*devicePixelRatio, y - 10*devicePixelRatio);
          }
          overlayCtx.restore();
        }
      }
    }

    // =========================
    // Loop
    // =========================
    async function tick(){
      if (!running) return;
      if (inflight >= 1) return;
      if (paused) return;

      inflight++;
      setProcessing(true);

      const localFrameId = ++frameId;
      frameIdEl.textContent = String(localFrameId);

      const t0 = performance.now();
      try{
        const snap = captureBase64();
        if (!snap) return;

        const payload = {
          session_id: sessionId,
          frame_id: localFrameId,
          ts_client_ms: Date.now(),
          image: { format: "jpeg", data_b64: snap.b64 },
          telemetry: {
            width: snap.w,
            height: snap.h,
            camera: facingMode,
            mirror: mirror,
            quality: jpegQuality,
            overlays: { landmarks: showLandmarks, labels: showLabels }
          }
        };

        const data = await post(payload);

        const t1 = performance.now();
        const rtt = Math.round(t1 - t0);
        const shownLatency = data?.latency_ms ?? rtt;
        latEl.textContent = shownLatency + "ms";

        if (!data || data.ok !== true){
          setStatus("bad", "FAULT");
          toastMsg("bad", "ATLAS fault", (data?.error?.code || "SERVER_FAULT") + " ‚Äî " + (data?.error?.message || "Unknown error"),
            debugEnabled ? `frame ${localFrameId}` : "");
          lastHands = [];
          drawHands(lastHands);
          setDock(lastHands);
          return;
        }

        lastHands = data.hands || [];
        drawHands(lastHands);
        setDock(lastHands);

        if (lastHands.length){
          setStatus("ok", "TRACKING");
          if (!debugEnabled) {
            // keep it quiet in normal mode
          } else {
            toastMsg("ok", "ATLAS", `Hands: ${lastHands.length}`, `lat ${shownLatency}ms`);
          }
        } else {
          setStatus("warn", "SEEKING");
          if (debugEnabled){
            toastMsg("warn", "ATLAS", "No hands detected", data?.warnings?.[0] || "");
          }
        }

      } catch (e){
        setStatus("bad", "FAULT");
        toastMsg("bad", "ATLAS fault", e?.message || String(e));
      } finally {
        inflight--;
        setProcessing(false);
      }
    }

    function startLoop(){
      clearInterval(timer);
      timer = setInterval(tick, RATE[currentRate].interval);
    }

    function stopLoop(){
      running = false;
      clearInterval(timer);
      timer = null;
      inflight = 0;
      setStatus("", "STANDBY");
      setProcessing(false);

      lastHands = [];
      drawHands(lastHands);
      setDock(lastHands);

      frameIdEl.textContent = "‚Äî";
      latEl.textContent = "‚Äî";
      toastMsg("", "ATLAS", "Standby.");
    }

    // =========================
    // UI events
    // =========================
    document.querySelectorAll('[data-rate]').forEach(btn => {
      btn.addEventListener("click", () => setRate(btn.dataset.rate));
    });

    function setFacing(mode){
      facingMode = mode;
      camFront.classList.toggle("active", facingMode === "user");
      camBack.classList.toggle("active", facingMode === "environment");
      toastMsg("warn", "ATLAS", "Switching camera‚Ä¶");
    }

    async function restartCamera(){
      if (!running) return;
      await stopCamera();
      await startCamera();
      toastMsg("ok", "ATLAS", `Camera: ${facingMode === "user" ? "Front" : "Back"}`);
    }

    camFront.addEventListener("click", async () => {
      setFacing("user");
      await restartCamera();
    });
    camBack.addEventListener("click", async () => {
      setFacing("environment");
      await restartCamera();
    });

    function toggle(el, get, set){
      const next = !get();
      set(next);
      setToggle(el, next);
      return next;
    }

    mirrorToggle.addEventListener("click", () => {
      const v = toggle(mirrorToggle, () => mirror, x => mirror = x);
      video.style.transform = v ? "scaleX(-1)" : "none";
      toastMsg("ok", "ATLAS", `Mirror: ${v ? "ON" : "OFF"}`);
    });

    lmToggle.addEventListener("click", () => {
      const v = toggle(lmToggle, () => showLandmarks, x => showLandmarks = x);
      toastMsg("ok", "ATLAS", `Landmarks: ${v ? "ON" : "OFF"}`);
      drawHands(lastHands);
    });

    lblToggle.addEventListener("click", () => {
      const v = toggle(lblToggle, () => showLabels, x => showLabels = x);
      toastMsg("ok", "ATLAS", `Labels: ${v ? "ON" : "OFF"}`);
      drawHands(lastHands);
    });

    // keyboard accessibility for toggles
    [mirrorToggle,lmToggle,lblToggle].forEach(el => {
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          el.click();
        }
      });
    });

    debugBtn.addEventListener("click", () => {
      if (debugEnabled){ setDebug(false); return; }
      const pw = prompt("Enter debug password:");
      if (pw === "cisco") setDebug(true);
      else toastMsg("bad", "ATLAS", "Incorrect password.");
    });

    startBtn.addEventListener("click", async () => {
      try{
        startBtn.disabled = true;
        setStatus("warn", "STARTING");
        toastMsg("warn", "ATLAS", "Requesting camera access‚Ä¶");

        await startCamera();

        running = true;
        stopBtn.disabled = false;

        setRate(currentRate);
        startLoop();

        setStatus("ok", "ONLINE");
        toastMsg("ok", "ATLAS", "Online. Hand tracking active.");
      } catch (e){
        startBtn.disabled = false;
        setStatus("bad", "FAULT");
        toastMsg("bad", "Camera fault", e?.message || String(e));
      }
    });

    stopBtn.addEventListener("click", async () => {
      stopLoop();
      await stopCamera();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      toastMsg("warn", "ATLAS", "Camera off.");
    });

    // =========================
    // Init
    // =========================
    sessionLine.textContent = `session: ${sessionId}`;
    setStatus("", "STANDBY");

    setToggle(mirrorToggle, true);
    setToggle(lmToggle, true);
    setToggle(lblToggle, true);

    setRate("normal");
    setDock([]);
    toastMsg("", "ATLAS", "Ready. Turn Camera On to begin.");
  </script>
</body>
</html>